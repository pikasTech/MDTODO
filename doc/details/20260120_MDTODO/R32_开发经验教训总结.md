# VSCode 插件开发经验教训总结

## 一、项目概述

本项目开发了一个 MDTODO VSCode 插件，用于将 Markdown TODO 文件渲染为树形任务列表，并支持 Claude Code 集成任务执行。项目历时 5 个主要阶段，解决了 30+ 个技术问题，积累了丰富的 VSCode 插件开发经验。

**核心成果**：
- 实现了 Markdown 任务解析与渲染、WebView 通信、状态管理、Claude 集成等核心功能
- 形成了完整的迭代开发流程和测试驱动开发模式
- 沉淀了可复用的技术架构和开发经验

## 二、开发模式总结

### 2.1 迭代式开发流程

```
需求 → 调研 → 规划 → 分阶段执行 → 测试 → 修复 → 总结
```

**核心实践**：

1. **分阶段执行**：将大项目拆分为 5 个明确阶段，每个阶段有清晰的目标和交付物
2. **任务追踪**：使用 Markdown 文件作为任务追踪系统，RXX 编号 + 状态标记（Finished/Processing/Pending）
3. **详细记录**：每个任务的执行、测试、修复过程都有详细文档记录，便于回顾和复盘
4. **及时总结**：遇到重复问题时及时总结规律，避免同类问题反复出现

### 2.2 测试驱动开发模式

**为什么需要测试驱动**：
- Markdown 解析涉及复杂的边界情况（换行符、层级关系、空行处理等）
- 手动测试难以覆盖所有场景，容易遗漏边界情况
- 代码修改后难以保证不破坏已有功能

**测试策略**：

1. **单元测试**：针对核心解析逻辑（任务解析、删除、多行编辑）编写完整测试用例
2. **真实文档测试**：使用实际项目文档（20260120_MDTODO.md）作为测试数据
3. **边界测试**：专门测试极端情况（首任务、尾任务、空任务、特殊字符等）
4. **回归测试**：每次修复后运行全部测试，确保不引入新问题

**测试覆盖率关键点**：
- 解析：单行内容、多行内容、嵌套任务、普通文本块
- 编辑：换行符保留、层级边界、撤销/重做
- 删除：精确匹配、层级边界、连续删除
- 状态转换：Pending → Finished, Processing

### 2.3 问题复现与修复模式

**核心原则**：先用单元测试复现问题，再修复代码，最后验证测试通过

**标准流程**：
1. 编写测试用例，描述期望行为
2. 运行测试，确认失败（复现问题）
3. 分析问题根因
4. 修复代码
5. 运行测试，确认通过
6. 记录问题分析过程

**这种模式的优势**：
- 确保问题真正被修复，而非临时绕过
- 防止问题反复出现（回归）
- 为后续维护提供安全保障

## 三、技术架构要点

### 3.1 整体架构

```
VSCode 编辑器 <---> WebViewProvider (TypeScript) <---> WebView (React)
       |                          |
       | postMessage              | acquireVsCodeApi
       |                          |
    文件系统 (.md)              状态管理 (React)
```

**核心设计原则**：
- **单向数据流**：WebView 只负责展示，所有文件操作由 Extension 处理
- **消息通信**：通过 `postMessage` 进行 VSCode 与 WebView 之间的通信
- **状态隔离**：编辑中的任务不响应外部刷新，保持独立状态

### 3.2 数据结构设计

**任务模型关键字段**：
- `id`: 任务唯一标识（R1, R2, R1.1 等）
- `lineNumber`: 任务在源文件中的行号（用于滚动同步）
- `status`: 状态（Pending/Finished/Processing）
- `isEditing`: 是否处于编辑模式
- `content`: 任务内容（可能包含多行）
- `children`: 子任务列表

**重要经验**：行号信息必须在解析阶段就收集，而不是后期计算，否则会导致滚动同步等功能难以实现。

### 3.3 消息协议设计

**消息类型分类**：

| 类型 | 方向 | 用途 |
|-----|------|------|
| updateTasks | Extension → WebView | 全量任务数据更新 |
| updateTextBlocks | Extension → WebView | 普通文本块更新 |
| editTask | WebView → Extension | 编辑任务 |
| saveTask | WebView → Extension | 保存任务 |
| deleteTask | WebView → Extension | 删除任务 |
| executeTask | WebView → Extension | 执行 Claude 任务 |
| scrollToTask | Extension → WebView | 滚动到指定任务 |
| webviewScrolled | WebView → Extension | WebView 滚动事件 |

**设计原则**：
- 消息类型使用字符串字面量，便于类型检查和调试
- 考虑消息的幂等性，重复消息不会导致错误
- 大数据量传输考虑增量更新而非全量刷新

## 四、核心难点与解决方案

### 4.1 多行内容编辑

**难点描述**：
编辑多行内容时，需要精确定位替换范围，容易出现以下问题：
- 误删子任务（替换范围计算错误）
- 换行符丢失或数量错误
- 编辑后文件格式混乱

**根本原因**：
- Markdown 任务块的结构是：`标题 + 换行符 + 内容 + 换行符 + 下一个任务`
- 多行内容可能被误判为子任务
- 换行符（`\n\n`）的数量需要严格控制

**解决思路**：
1. **分层查找**：先找到任务标题行，再区分"内容区域"和"子任务区域"
2. **精确匹配**：使用正则表达式精确匹配任务 ID，避免部分匹配（如 R1 误匹配 R10）
3. **保留换行**：文件末尾的换行符需要特殊处理

**可复用经验**：
- 文本替换时，先找到起始边界，再找到结束边界，最后进行替换
- 层级结构（`##` vs `###`）是判断边界的可靠依据
- 使用单元测试覆盖各种边界情况

### 4.2 状态同步与编辑保护

**难点描述**：
- 多个任务同时处于编辑模式
- 编辑时外部刷新覆盖内容
- 编辑完成但 UI 不同步

**解决思路**：
1. **单一编辑模式**：确保同一时刻最多一个任务处于编辑模式
2. **编辑保护**：编辑中的任务不响应外部刷新
3. **状态持久化**：使用 ref 跟踪正在编辑的任务，刷新后保持状态

**关键代码模式**：
```typescript
// 进入编辑时，取消其他任务的编辑状态
const startEditing = (taskId: string) => {
  setTasks(tasks.map(t => ({
    ...t,
    isEditing: t.id === taskId
  })));
};

// 使用 ref 保护编辑状态
const editingTaskIdsRef = useRef(new Set());
editingTaskIdsRef.current = editingTaskIds;
```

**可复用经验**：
- React 中使用 ref 来保存需要跨渲染保持的状态
- useEffect 的清理函数中处理副作用
- 外部数据刷新时，根据 ref 决定是否保留编辑状态

### 4.3 换行符与格式控制

**难点描述**：
Markdown 格式对换行符有严格要求：
- 标题与内容之间需要两个换行符 `\n\n`
- 任务与任务之间需要两个换行符
- 文件末尾通常需要一个换行符

编辑操作容易破坏这些格式规则。

**解决思路**：
1. **明确规范**：Markdown 语法规定标题与内容之间必须有空行
2. **严格控制**：写入文件时使用固定格式，不依赖用户输入
3. **边界处理**：首任务、尾任务、只有单一任务等边界情况单独处理

**格式规范**：
```
## R1 任务标题

任务内容第一行

任务内容第二行

## R2 下一个任务
```

**可复用经验**：
- 格式规则要严格遵守，不要"差不多"
- 换行符问题容易累积，要及时用测试覆盖
- 定义清晰的格式规范，写入时严格遵循

### 4.4 链接点击与路径解析

**难点描述**：
- 相对路径解析（`./doc.md` vs `/absolute/path.md`）
- URL 编码问题（中文路径、双重编码）
- marked 库对链接的自动转换

**解决思路**：
1. **路径解析**：使用 `path.resolve()` 基于当前文件目录解析相对路径
2. **URL 解码**：使用 `decodeURIComponent()` 解码，支持双重编码
3. **渲染配置**：配置 marked 渲染器保持原始链接不变

**可复用经验**：
- 处理用户输入时，要考虑各种编码情况
- 相对路径必须基于"当前文件目录"而非"工作目录"
- 第三方库的默认行为可能不符合需求，需要自定义配置

### 4.5 双向滚动同步

**难点描述**：
- VSCode 编辑器滚动 → WebView 任务列表同步滚动
- WebView 滚动 → VSCode 编辑器同步滚动
- 避免循环同步（一边滚动触发另一边，另一边又触发回来）

**解决思路**：
1. **行号关联**：解析时记录每个任务在源文件中的行号
2. **节流控制**：双向同步都实现 300ms 节流
3. **状态标记**：使用 ref 跟踪上次滚动的任务，避免重复触发

**关键逻辑**：
```typescript
// 查找最接近当前可见行的任务
const findNearestTask = (lineNumber: number) => {
  let nearestTask: Task | undefined;
  let minDistance = Infinity;

  for (const task of tasks) {
    const distance = Math.abs(task.lineNumber - lineNumber);
    if (distance < minDistance) {
      minDistance = distance;
      nearestTask = task;
    }
  }
  return nearestTask;
};
```

**可复用经验**：
- 双向同步需要"主动/被动"状态管理，避免循环触发
- 节流是处理高频事件的常用手段
- 行号信息应该在解析阶段收集，而非后期计算

## 五、常见陷阱与规避

### 5.1 文本解析陷阱

| 陷阱 | 规避方法 |
|-----|---------|
| 部分匹配 | 使用正则表达式的单词边界 `\b` 或行首锚点 `^` |
| 空行处理 | 明确空行是保留在文本块中，还是作为分隔符 |
| 层级判断 | 基于标题符号数量（`#` 的个数）判断层级，而非内容缩进 |
| 编码问题 | 使用 UTF-8 统一编码，处理 URL 编码时考虑双重编码 |

### 5.2 React 开发陷阱

| 陷阱 | 规避方法 |
|-----|---------|
| 闭包陷阱 | 使用 `useRef` 保存最新值，或使用函数式更新 |
| 过度渲染 | 使用 `React.memo` 包装组件，`useMemo` 缓存计算 |
| 内存泄漏 | 在 `useEffect` 返回清理函数，移除事件监听 |
| 状态不一致 | 单一数据源，避免状态冗余，使用不可变更新 |

### 5.3 VSCode API 陷阱

| 陷阱 | 规避方法 |
|-----|---------|
| WebView 安全 | 配置 `csp` 内容安全策略，禁用 `eval` |
| 资源路径 | 使用 `webview.asWebviewUri` 转换资源路径 |
| 消息丢失 | 使用 `acquireVsCodeApi`，确保消息处理完整 |
| 状态持久化 | 使用 `globalState` 或 `workspaceState` 保存设置 |

### 5.4 文件操作陷阱

| 陷阱 | 规避方法 |
|-----|---------|
| 并发写入 | 操作前备份文件，操作后验证格式 |
| 格式破坏 | 使用正则表达式定位，操作前后验证格式 |
| 换行符问题 | 明确换行符数量规范，写入时严格控制 |

## 六、调试与问题排查技巧

### 6.1 日志策略

**关键位置添加日志**：
- 消息收发入口和出口
- 文件读写操作前后
- 状态转换关键节点
- 边界条件判断位置

**日志格式**：
```
[模块名] 操作描述: 输入参数 -> 处理结果
```

**示例**：
```
[MDTODO] handleOpenLink 收到 URL: ./test.md
[MDTODO] 解码后的 URL: ./test.md
[MDTODO] 相对路径解析: ./test.md -> D:\project\test.md
[MDTODO] 已打开文档: D:\project\test.md
```

### 6.2 常见问题排查流程

1. **确认问题现象**：准确描述问题的表现（期望行为 vs 实际行为）
2. **分析可能原因**：列出可能导致问题的代码位置
3. **添加日志验证**：在关键位置添加日志，确认数据流向
4. **编写测试复现**：创建最小复现用例
5. **定位根因**：分析日志和测试结果，确定根本原因
6. **修复验证**：修复后运行测试，确认问题解决

### 6.3 单元测试调试技巧

1. **逐步缩小范围**：注释掉部分测试用例，定位问题
2. **打印中间结果**：在测试中添加 `console.log` 查看中间值
3. **使用断点**：在 VSCode 中设置断点，逐步执行
4. **对比预期值**：明确期望结果与实际结果的差异

## 七、可复用组件与模式

### 7.1 任务列表组件模式

**Props 接口设计**：
```typescript
interface TaskItemProps {
  task: Task;
  depth: number;              // 层级深度，用于缩进
  isExpanded: boolean;        // 是否展开
  isEditing: boolean;         // 是否编辑中
  onToggle: (taskId: string) => void;
  onEdit: (taskId: string) => void;
  onSave: (taskId: string, content: string) => void;
  onDelete: (taskId: string) => void;
  onExecute: (taskId: string) => void;
  onToggleComplete: (taskId: string) => void;
}
```

**设计要点**：
- 深度传参，避免递归组件中的深度计算
- 回调函数使用柯里化模式，便于添加防抖
- 支持多级子任务的递归渲染

### 7.2 防抖模式

**按钮防抖（0.5秒冷却）**：
```typescript
function createDebouncedHandler<T>(
  fn: (...args: T[]) => void,
  delay: number
): (...args: T[]) => void {
  let timeoutId: NodeJS.Timeout | null = null;
  return (...args: T[]) => {
    if (timeoutId) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}
```

**使用场景**：
- Claude 执行按钮（防止重复点击）
- 保存操作（减少频繁保存）
- 滚动事件（节流控制）

### 7.3 Markdown 解析器模式

**核心解析逻辑**：
1. 按行扫描，维护当前任务状态
2. 遇到新任务标题时，完成上一个任务
3. 非任务行视为任务内容或普通文本
4. 使用正则表达式精确匹配任务 ID

**关键正则**：
```typescript
// 任务标题匹配（行首的 RXX 或 RXX.X）
const taskTitlePattern = /^##?\s*(R\d+(?:\.\d+)*)\s*\[?([^\]]*)\]?/;

// 任务边界检测（任意任务标题行）
const taskBoundaryPattern = /^##?\s*R\d+/;
```

## 八、后续改进建议

### 8.1 功能增强方向

1. **任务模板**：预设任务模板，快速创建标准化任务
2. **批量操作**：批量标记完成、删除、移动
3. **全文搜索**：搜索任务内容，高亮显示结果
4. **数据导出**：导出为 CSV、JSON 等格式

### 8.2 性能优化方向

1. **虚拟列表**：大任务列表使用虚拟滚动
2. **增量更新**：文件变化时只更新变化部分
3. **缓存机制**：缓存解析结果，减少重复计算

### 8.3 架构优化方向

1. **状态管理**：引入 Redux 或 Zustand 管理复杂状态
2. **组件拆分**：将 TaskList 拆分为更细粒度的组件
3. **TypeScript 强化**：增加更多类型约束，减少运行时错误

## 九、总结

本项目通过迭代式开发，成功实现了 VSCode TODO 管理插件。核心经验总结如下：

### 开发模式层面

1. **测试驱动开发**：复杂逻辑必须用单元测试覆盖，确保可维护性
2. **先复现后修复**：先用测试复现问题，再修复代码，避免临时绕过
3. **详细记录**：每个问题的分析过程和解决方案都要记录，便于后续参考

### 技术层面

1. **明确规范**：Markdown 格式、换行符数量等规范要明确定义并严格遵守
2. **精确匹配**：任务 ID、边界判断等必须精确，避免部分匹配
3. **状态保护**：编辑状态需要特殊保护，避免被外部刷新覆盖
4. **路径解析**：相对路径必须基于当前文件目录，考虑 URL 编码

### 项目管理层面

1. **任务追踪**：使用 RXX 编号 + 状态标记的追踪系统行之有效
2. **阶段划分**：5 阶段划分（调研、规划、开发、测试、完善）清晰可行
3. **文档同步**：执行记录与代码同步更新，保持一致性

这些经验可以为后续 VSCode 插件开发项目提供参考和借鉴。

---

**文档信息**
- 创建日期：2026-01-21
- 任务 ID：R32
- 状态：[Finished]
- 最后更新：2026-01-21（根据 R32.1 要求重写，增加重点难点总结和可复用经验）
