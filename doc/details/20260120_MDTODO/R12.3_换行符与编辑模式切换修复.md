# R12.3 换行符与编辑模式切换修复

## 任务内容

1. 要求的是在完成编辑后，在RXX行和内容行之间有\n\n，现在没有实现这个目标，应该是加错了位置。
2. 回车后webui依然没有切换到非编辑模式。

## 问题分析

### 问题1：换行符位置问题

原代码在 `handleSaveTitle` 中，当找到现有内容行时，只是更新内容行而没有检查/添加换行符：
```typescript
// 找到内容行
contentLineIndex = i;
lines[contentLineIndex] = newTitle;  // 没有添加换行符
```

如果任务标题和内容行之间没有空行，更新后会丢失换行符。

### 问题2：回车后编辑模式不切换

两个原因：
1. `saveCompleteCallback` 可能为 null（因为 useEffect 还未执行）
2. `loadFile` 调用会触发 `updateTasks` 消息，重置 `editModes` 状态

## 修复内容

### 1. 换行符修复

**文件**: `vscode-mdtodo/src/providers/webviewProvider.ts`

```typescript
// 找到内容行，确保任务标题和内容之间有换行符
if (contentLineIndex === -1) {
  contentLineIndex = taskLineIndex + 1;
  lines.splice(contentLineIndex, 0, `${newTitle}\n\n`);
} else {
  // 如果内容行紧跟在任务标题后面（没有空行），需要插入换行符
  if (contentLineIndex === taskLineIndex + 1) {
    lines[contentLineIndex] = `\n\n${newTitle}`;
  } else {
    lines[contentLineIndex] = newTitle;
  }
}
```

### 2. saveCompleteCallback 防抖修复

**文件**: `vscode-mdtodo/src/webview/index.tsx`

```typescript
// 使用防抖确保回调在 useEffect 注册前被调用时不会出错
let saveCompleteCallback: ((taskId: string) => void) | null = null;
let lastTaskId: string | null = null;
let callbackCheckTimer: NodeJS.Timeout | null = null;

// 防抖处理：等待回调注册完成后调用
const scheduleCallbackCheck = (taskId: string) => {
  lastTaskId = taskId;
  if (callbackCheckTimer) {
    clearTimeout(callbackCheckTimer);
  }
  callbackCheckTimer = setTimeout(() => {
    if (saveCompleteCallback && lastTaskId) {
      saveCompleteCallback(lastTaskId);
    }
    lastTaskId = null;
    callbackCheckTimer = null;
  }, 50);
};

const handleSaveComplete = (taskId: string) => {
  if (saveCompleteCallback) {
    saveCompleteCallback(taskId);
  } else {
    scheduleCallbackCheck(taskId);  // 等待回调注册
  }
};
```

### 3. editModes 状态保持修复

**文件**: `vscode-mdtodo/src/webview/components/TaskList.tsx`

添加 `editingTaskIds` 状态和 ref 来跟踪正在编辑的任务：

```typescript
// 用于保存正在编辑的任务ID，防止文件重载后丢失编辑状态
const [editingTaskIds, setEditingTaskIds] = React.useState<Set<string>>(new Set());
const editingTaskIdsRef = React.useRef(editingTaskIds);
editingTaskIdsRef.current = editingTaskIds;
```

修改 `handleDoubleClick` 跟踪进入编辑模式的任务：

```typescript
const handleDoubleClick = (taskId: string) => {
  setEditModes((prev) => ({
    ...prev,
    [taskId]: true,
  }));
  setEditingTaskIds((prev) => new Set(prev).add(taskId));
};
```

修改 `handleSaveComplete` 清除编辑标记：

```typescript
const handleSaveComplete = (taskId: string) => {
  setEditModes((prev) => ({
    ...prev,
    [taskId]: false,
  }));
  setEditingTaskIds((prev) => {
    const next = new Set(prev);
    next.delete(taskId);
    return next;
  });
  // ...
};
```

修改 `updateTasks` 处理，保留正在编辑任务的编辑模式：

```typescript
if (message.type === 'updateTasks') {
  setTasks(message.tasks || []);
  setTextBlocks(message.textBlocks || []);
  const allTaskIds = getAllTaskIds(message.tasks || []);
  setExpandedTasks(new Set(allTaskIds));
  // 保留正在编辑的任务的编辑模式
  setEditModes((prev) => {
    const next: Record<string, boolean> = {};
    for (const taskId of allTaskIds) {
      if (editingTaskIdsRef.current.has(taskId)) {
        next[taskId] = true;
      }
    }
    return Object.keys(next).length > 0 ? next : prev;
  });
}
```

## 构建验证

```bash
cd vscode-mdtodo
npm.cmd run compile
# 构建成功
```

## 验证步骤

1. 在 VSCode 中打开插件项目
2. 重新加载窗口（Ctrl+Shift+P -> "Reload Window"）
3. 打开一个 TODO 文件（如 20260120_MDTODO.md）
4. 双击一个任务进入编辑模式
5. 修改内容，按回车键
6. 验证：
   - md 文件中任务标题和内容之间有空行
   - 编辑完成后 webui 自动切换到非编辑模式

## 状态

- [x] 换行符修复完成
- [x] saveCompleteCallback 防抖修复完成
- [x] editModes 状态保持修复完成
- [x] 构建验证通过
