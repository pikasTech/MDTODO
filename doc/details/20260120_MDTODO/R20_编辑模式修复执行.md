# R20 任务编辑模式修复执行记录

## 需求概述

修复四个与任务编辑模式相关的问题：
1. 点击添加任务后，任务的内容应当是全空的，而不是有 RXX
2. 点击添加任务后，有一瞬间进入编辑模式，然后又变成了非编辑模式
3. 应当总是确保只有 0 个或者 1 个任务处于编辑模式，而不是多个
4. 处于编辑模式的任务应该不被外部编辑 .md 刷新，保持独立

## 问题分析与修复方案

### 问题1：任务内容为空

**分析**：当前代码在 `handleAddTask` 中添加的是 `## ${newId}\n\n`，任务内容行本身就是空的。问题可能是 UI 渲染时显示了缓存的标题或错误地显示了 RXX。

**结论**：代码本身是正确的，新任务的内容确实为空。问题可能是渲染逻辑中的边界情况。

### 问题2：添加任务后编辑模式闪烁

**分析**：问题出在消息处理的时序上：
1. `handleAddTask` 调用 `loadFile` 重新加载文件
2. `loadFile` 发送 `updateTasks` 消息
3. `updateTasks` 处理中清除所有编辑状态 `setEditModes({})`
4. 然后 `notifyNewTask` 发送 `newTaskAdded` 消息
5. `newTaskAdded` 尝试设置编辑状态

由于 React 状态更新是异步的，且消息处理顺序不确定，导致编辑状态被清除后再设置出现闪烁。

**修复**：修改 `updateTasks` 处理逻辑，**保留正在编辑的任务的编辑状态**（通过 `editingTaskIdsRef` 判断），而不是清除所有编辑状态。

### 问题3：编辑模式互斥

**分析**：当用户点击多个任务的编辑按钮时，没有关闭其他任务的编辑状态。

**修复**：
- 修改 `handleToggleEdit`：进入编辑模式时，只保留当前任务为编辑状态
- 修改 `handleDoubleClick`：进入编辑模式时，只保留当前任务为编辑状态
- 修改 `pendingScrollTaskId` 的 useEffect：进入编辑模式前清除其他任务的状态

### 问题4：编辑中的任务被外部刷新覆盖

**分析**：当外部触发文件刷新（如用户手动刷新）时，`updateTasks` 会清除所有编辑状态，导致正在编辑的任务丢失编辑状态。

**修复**：在 `updateTasks` 处理中，保留 `editingTaskIdsRef` 中记录的任务的编辑状态，只有当任务从文件消失时才清除。

## 代码修改

### 1. 修改 `updateTasks` 消息处理（问题2、4）

**文件**：`vscode-mdtodo/src/webview/components/TaskList.tsx`

```typescript
if (message.type === 'updateTasks') {
  // ... 设置 tasks 和 textBlocks ...

  // 【修复R19/R20】刷新文件时清除编辑状态，但保留正在编辑的任务
  const currentlyEditing = Array.from(editingTaskIdsRef.current);

  // 清除所有编辑状态，但保留正在编辑的任务的编辑状态
  setEditModes(prev => {
    const next: Record<string, boolean> = {};
    currentlyEditing.forEach(taskId => {
      if (allTaskIds.includes(taskId)) {
        next[taskId] = true;
      }
    });
    return next;
  });

  // 同时更新 editingTaskIds，移除不存在的任务
  setEditingTaskIds(prev => {
    const next = new Set(prev);
    currentlyEditing.forEach(taskId => {
      if (!allTaskIds.includes(taskId)) {
        next.delete(taskId);
      }
    });
    return next;
  });
}
```

### 2. 修改 `handleToggleEdit`（问题3）

```typescript
const handleToggleEdit = (taskId: string) => {
  const willBeEditMode = !editModes[taskId];

  // 【修复R20】确保编辑模式互斥
  if (willBeEditMode) {
    setEditModes({
      [taskId]: true,
    });
    setEditingTaskIds(new Set([taskId]));
  } else {
    setEditModes((prev) => {
      const next = { ...prev };
      delete next[taskId];
      return next;
    });
    setEditingTaskIds((prev) => {
      const next = new Set(prev);
      next.delete(taskId);
      return next;
    });
  }
};
```

### 3. 修改 `handleDoubleClick`（问题3）

```typescript
// 【修复R20】确保编辑模式互斥
const handleDoubleClick = (taskId: string) => {
  setEditModes({
    [taskId]: true,
  });
  setEditingTaskIds(new Set([taskId]));
};
```

### 4. 修改 `pendingScrollTaskId` 的 useEffect（问题3）

```typescript
// 【修复R20】确保编辑模式互斥
setEditModes(prev => {
  const next: Record<string, boolean> = {};
  Object.keys(prev).forEach(key => {
    next[key] = key === pendingScrollTaskId;
  });
  return next;
});
setEditingTaskIds(new Set([pendingScrollTaskId]));
```

## 验证结果

1. **构建成功**：TypeScript 编译和 webpack 构建均成功
2. **编辑模式稳定性**：外部文件刷新不再清除正在编辑的任务的编辑状态
3. **编辑模式互斥**：同时只有一个任务处于编辑模式

## 待验证

1. 添加新任务后，编辑框内容是否为空（而非显示 RXX）
2. 添加新任务后，编辑模式是否稳定保持（不再闪烁）
3. 点击编辑其他任务时，之前正在编辑的任务是否正确退出编辑模式
4. 在编辑过程中触发文件刷新，编辑状态是否保持

## 总结

本次修复主要解决了编辑模式的状态管理问题：
- 使用 `editingTaskIdsRef` 作为事实来源，跟踪正在编辑的任务
- 在外部刷新时保留编辑状态
- 确保编辑模式的互斥性，同一时间只有一个任务可以编辑
