# R19 编辑模式误触发修复

## 问题描述

有时候莫名其妙进入编辑模式，而且还会切换到其他的任务里面编辑。这个行为应该是新建任务的时候才触发才对，是否是因为其他的操作误触发了这个行为。

## 问题分析

经过代码分析，发现以下几个可能导致误触发编辑模式的原因：

### 1. 文件刷新时错误保留编辑状态

在 `TaskList.tsx` 的 `updateTasks` 消息处理中，原代码会尝试根据 `editingTaskIdsRef` 保留编辑模式状态：

```typescript
// 原代码问题：刷新文件时可能错误保留旧的编辑状态
setEditModes((prev) => {
  const next: Record<string, boolean> = {};
  for (const taskId of allTaskIds) {
    if (editingTaskIdsRef.current.has(taskId)) {
      next[taskId] = true;
    }
  }
  return Object.keys(next).length > 0 ? next : prev;
});
```

问题是 `editingTaskIds` 状态可能在某些情况下没有正确管理，导致刷新后保留了不应有的编辑状态。

### 2. 外部调用未同步管理状态

当外部调用 `window.MDTODO.updateTaskState` 刷新任务标题时，只会更新任务内容，不会同步清除编辑状态，可能导致状态不一致。

### 3. `pendingScrollTaskId` 触发时机

`pendingScrollTaskId` 会在任务更新后自动进入编辑模式，但这个机制只应该在添加新任务时触发，不应该在其他刷新操作中触发。

## 修复方案

### 1. 刷新文件时清除所有编辑状态

修改 `updateTasks` 消息处理逻辑，刷新文件时清除所有编辑状态：

```typescript
if (message.type === 'updateTasks') {
  // ...
  // 【修复R19】刷新文件时清除所有编辑状态，避免误触发编辑模式
  setEditModes({});
  setEditingTaskIds(new Set());
  console.log('[Webview] updateTasks: 已清除所有编辑状态');
}
```

### 2. 正确设置新任务的编辑状态

在 `newTaskAdded` 消息处理中，正确标记新任务正在编辑：

```typescript
} else if (message.type === 'newTaskAdded') {
  setPendingScrollTaskId(message.taskId);
  // 【修复R19】标记新任务正在编辑
  setEditingTaskIds(new Set([message.taskId]));
  console.log('[Webview] newTaskAdded: 设置新任务', message.taskId, '为编辑状态');
  // ...
}
```

### 3. 刷新任务标题后清除编辑状态

在 `handleRefreshTaskTitle` 中清除编辑状态：

```typescript
const handleRefreshTaskTitle = (taskId: string, newTitle: string) => {
  // ... 更新任务内容 ...
  // 清除该任务的编辑状态（刷新标题意味着完成编辑）
  setEditModes((prev) => {
    const next = { ...prev };
    delete next[taskId];
    return next;
  });
  setEditingTaskIds((prev) => {
    const next = new Set(prev);
    next.delete(taskId);
    return next;
  });
};
```

### 4. 同步更新 `editingTaskIds`

修改 `handleToggleEdit` 以同步更新 `editingTaskIds`：

```typescript
const handleToggleEdit = (taskId: string) => {
  const willBeEditMode = !editModes[taskId];
  console.log('[Webview] handleToggleEdit:', taskId, '->', willBeEditMode ? '编辑模式' : '非编辑模式');
  setEditModes((prev) => ({
    ...prev,
    [taskId]: !prev[taskId],
  }));
  // 同步更新 editingTaskIds
  if (willBeEditMode) {
    setEditingTaskIds((prev) => new Set(prev).add(taskId));
  } else {
    setEditingTaskIds((prev) => {
      const next = new Set(prev);
      next.delete(taskId);
      return next;
    });
  }
};
```

### 5. 增加调试日志

为所有编辑模式相关的操作添加日志输出，便于后续排查问题：
- `handleSaveComplete`: 保存完成后退出编辑模式
- `handleDoubleClick`: 双击进入编辑模式
- `handleToggleEdit`: 编辑按钮切换
- `pendingScrollTaskId` effect: 新任务自动进入编辑模式
- `updateTasks`: 文件刷新清除编辑状态
- `newTaskAdded`: 新任务添加进入编辑模式
- `handleRefreshTaskTitle`: 刷新任务标题

## 修复后的行为

1. **添加新任务**：自动滚动到新任务并进入编辑模式
2. **双击任务**：进入该任务的编辑模式
3. **点击编辑按钮**：切换该任务的编辑模式
4. **刷新文件**：清除所有编辑状态，不自动进入任何编辑模式
5. **保存完成/点击完成**：退出编辑模式

## 修改文件

- `src/webview/components/TaskList.tsx`

## 构建验证

```
npm.cmd run compile
```

构建成功，webpack 编译无误。
