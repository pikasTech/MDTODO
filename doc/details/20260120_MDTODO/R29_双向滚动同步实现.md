# R29 双向滚动同步实现

## 需求描述

如果 VSCODE 左侧的 TagTree 打开了 md 的源文件，右侧打开了 MDTODO 插件，那么应该实现双向的滚动同步。

## 实现方案

### 1. 数据层面修复

**问题**：parser 中 `parseTask` 方法没有传递 `lineNumber` 参数，导致任务无法关联到文件中的具体行号。

**修复**：
- 修改 `parseTask` 方法签名，添加 `lineNumber: number` 参数
- 在返回的 TodoTask 对象中使用传入的 lineNumber
- 修改调用处，将 token.lineNumber 传递给 parseTask

文件：`vscode-mdtodo/src/parser/index.ts`

```typescript
// 修改方法签名
private parseTask(content: string, rawContent: string, filePath: string, level: number, lineNumber: number): TodoTask {
    // ...
    return {
      id,
      title,
      description: title,
      rawContent,
      completed,
      processing,
      children: [],
      lineNumber,  // 使用传入的行号
      filePath
    };
}

// 修改调用处
const task = this.parseTask(fullContent, rawContent, filePath, token.level, token.lineNumber);
```

### 2. 任务序列化添加 lineNumber

**修改**：`serializeTasks` 方法中添加 `lineNumber` 字段传递给 webview。

文件：`vscode-mdtodo/src/providers/webviewProvider.ts`

```typescript
private serializeTasks(tasks: TodoTask[]): any[] {
  return tasks.map(task => ({
    id: task.id,
    title: task.title,
    description: task.description,
    completed: task.completed,
    processing: task.processing,
    children: task.children.length > 0 ? this.serializeTasks(task.children) : [],
    lineNumber: task.lineNumber,  // 添加 lineNumber
    hasChildren: task.children.length > 0,
    level: this.getTaskLevel(task.id)
  }));
}
```

### 3. Webview 任务接口更新

**修改**：在 Task 接口中添加可选的 `lineNumber` 字段。

文件：`vscode-mdtodo/src/webview/components/TaskList.tsx`

```typescript
interface Task {
  id: string;
  title: string;
  rawContent: string;
  completed: boolean;
  processing: boolean;
  children?: Task[];
  lineNumber?: number;  // 添加行号字段
}
```

### 4. VSCode 到 Webview 滚动同步

**实现**：监听 VSCode 编辑器的可见范围变化，当用户滚动编辑器时，查找最接近的任务并通知 webview 滚动到该任务。

文件：`vscode-mdtodo/src/providers/webviewProvider.ts`

```typescript
public setupScrollSync(): void {
  // 监听编辑器可见范围变化（滚动事件）
  vscode.window.onDidChangeTextEditorVisibleRanges((event) => {
    const editor = event.textEditor;

    // 检查是否是当前打开的TODO文件
    if (!this.currentFilePath || !editor) {
      return;
    }

    if (editor.document.uri.fsPath !== this.currentFilePath) {
      return;
    }

    // 获取可见范围的第一行
    const visibleRanges = editor.visibleRanges;
    if (visibleRanges.length > 0) {
      const firstVisibleLine = visibleRanges[0].start.line;

      // 查找最接近当前可见行的任务
      const nearestTask = this.findNearestTask(firstVisibleLine);

      if (nearestTask && this.panel) {
        // 发送滚动位置到webview
        this.panel.webview.postMessage({
          type: 'scrollToTask',
          taskId: nearestTask.id,
          lineNumber: nearestTask.lineNumber
        });
      }
    }
  }, undefined, this.context.subscriptions);
}

private findNearestTask(lineNumber: number): TodoTask | undefined {
  let nearestTask: TodoTask | undefined;
  let minDistance = Infinity;

  const findInTasks = (taskList: TodoTask[]) => {
    for (const task of taskList) {
      const distance = Math.abs(task.lineNumber - lineNumber);
      if (distance < minDistance) {
        minDistance = distance;
        nearestTask = task;
      }
      if (task.children && task.children.length > 0) {
        findInTasks(task.children);
      }
    }
  };

  findInTasks(this.currentTasks);
  return nearestTask;
}
```

### 5. Webview 到 VSCode 滚动同步

**实现**：监听 webview 的滚动事件，当用户滚动任务列表时，找到当前可见区域最顶部的任务，发送消息通知 VSCode 滚动到该任务所在行。

文件：`vscode-mdtodo/src/webview/components/TaskList.tsx`

```typescript
// 添加滚动同步相关状态和引用
const lastScrollTaskRef = React.useRef<string>('');
const SCROLL_THROTTLE = 300; // 滚动节流时间（毫秒）
const lastScrollTimeRef = React.useRef<number>(0);

// 处理滚动事件
const handleScroll = React.useCallback(() => {
  const now = Date.now();

  // 节流控制
  if (now - lastScrollTimeRef.current < SCROLL_THROTTLE) {
    return;
  }
  lastScrollTimeRef.current = now;

  // 查找当前可见区域中最顶部的任务
  const taskElements = document.querySelectorAll('[data-task-id]');
  let topmostTask: { id: string; lineNumber: number; element: Element } | null = null;
  let minTop = Infinity;

  const container = document.querySelector('.task-container');
  const containerRect = container?.getBoundingClientRect();

  if (!containerRect) return;

  taskElements.forEach((element) => {
    const taskId = element.getAttribute('data-task-id');
    if (!taskId) return;

    const rect = element.getBoundingClientRect();
    const relativeTop = rect.top - containerRect.top;

    // 计算元素顶部相对于容器顶部的位置
    if (relativeTop >= -50 && relativeTop < minTop) {
      minTop = relativeTop;
      const task = findTaskById(tasks, taskId);
      if (task) {
        topmostTask = { id: taskId, lineNumber: task.lineNumber || 0, element };
      }
    }
  });

  // 如果找到当前可见的任务，且与上一次不同，发送滚动消息到VSCode
  if (topmostTask && topmostTask.id !== lastScrollTaskRef.current) {
    lastScrollTaskRef.current = topmostTask.id;
    sendMessage({
      type: 'webviewScrolled',
      taskId: topmostTask.id,
      lineNumber: topmostTask.lineNumber
    });
  }
}, [tasks, sendMessage]);

// 添加滚动事件监听器
React.useEffect(() => {
  const container = document.querySelector('.task-container');
  if (container) {
    container.addEventListener('scroll', handleScroll, { passive: true });
    return () => {
      container.removeEventListener('scroll', handleScroll);
    };
  }
}, [handleScroll]);
```

### 6. 消息处理器

**Webview 端**：

```typescript
// 处理来自 VSCode 的滚动到任务消息
} else if (message.type === 'scrollToTask') {
  handleScrollToTask(message.taskId, message.lineNumber);
}

// 滚动到指定任务
const handleScrollToTask = (taskId: string, lineNumber: number) => {
  // 确保任务展开
  const parentId = taskId.split('.').slice(0, -1).join('.');
  if (parentId) {
    setExpandedTasks(prev => new Set([...prev, parentId]));
  }

  // 滚动到任务位置
  setTimeout(() => {
    const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
    if (taskElement) {
      taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      lastScrollTaskRef.current = taskId;
    }
  }, 50);
};
```

**VSCode Extension 端**：

```typescript
case 'webviewScrolled':
  await this.handleWebviewScrolled(message.taskId, message.lineNumber);
  break;

// 处理来自Webview的滚动事件
private async handleWebviewScrolled(taskId: string, lineNumber: number): Promise<void> {
  if (!this.currentFilePath || lineNumber < 0) {
    return;
  }

  const activeEditor = vscode.window.activeTextEditor;
  if (activeEditor && activeEditor.document.uri.fsPath === this.currentFilePath) {
    const position = new vscode.Position(lineNumber, 0);
    activeEditor.revealRange(
      new vscode.Range(position, position),
      vscode.TextEditorRevealType.InCenter
    );
  }
}
```

## 注意事项

1. **节流控制**：双向滚动同步都实现了 300ms 的节流，避免频繁触发
2. **避免循环同步**：通过 `lastScrollTaskRef` 跟踪上次滚动的任务，避免同一方向的重复同步
3. **任务展开**：当滚动到某个任务时，会自动展开其父任务
4. **边界情况**：处理了 lineNumber 为 0 或无效的情况

## 测试验证

构建命令：
```bash
cd vscode-mdtodo && npm.cmd run compile
```

测试步骤：
1. 在 VSCode 中打开一个 TODO 文件
2. 打开 MDTODO 插件面板
3. 在左侧编辑器中滚动文件，观察右侧面板是否同步滚动
4. 在右侧面板中滚动任务列表，观察左侧编辑器是否同步滚动
