# R51.9 任务报告

## 任务描述

跳转到子任务不应当导致子任务被展开，如果是折叠模式，应当在折叠模式下完成跳转。

## 问题分析

### 原有问题

原来的跳转功能存在以下问题：

1. **`handleJumpToTask` 函数** - 跳转下拉菜单
   - 每次跳转子任务时都会自动展开父任务

2. **`handleScrollToTask` 函数** - 滚动同步
   - 来自VSCode编辑器的滚动同步也会自动展开父任务

3. **`handleJumpToNextIncomplete` 函数** - 跳转到下一个未完成任务
   - 跳转到下一个未完成任务时也会自动展开父任务

这三个函数都会在跳转到子任务时调用：
```typescript
const parentId = taskId.split('.').slice(0, -1).join('.');
if (parentId) {
  setExpandedTasks(prev => new Set([...prev, parentId]));
}
```

## 解决方案

### 设计思路

1. **保留折叠状态**：跳转到子任务时不再自动展开父任务
2. **双层滚动机制**：
   - 第一层：滚动主容器到父任务位置，显示子任务区域（折叠状态下子任务区域高度为300px）
   - 第二层：滚动子任务区域内部，将目标子任务滚动到可见位置
3. **高亮定位目标**：使用蓝色脉冲高亮让用户知道定位位置
4. **自动清除高亮**：3秒后自动清除高亮效果

### 实现方案

1. **新增统一滚动函数 `scrollToTask`**：
   - 检查父任务是否已展开
   - 父任务已展开：直接滚动到目标
   - 父任务折叠：先滚动到父任务，再滚动子任务区域内部

2. **修改三个跳转函数都使用 `scrollToTask`**：
   - `handleJumpToTask` - 跳转下拉菜单
   - `handleScrollToTask` - 滚动同步
   - `handleJumpToNextIncomplete` - 跳转到下一个未完成任务

### 代码变更

#### TaskList.tsx

新增统一滚动函数 (第640-692行)：
```typescript
// 【R51.9】滚动到目标任务：支持折叠模式下的双层滚动
const scrollToTask = (taskId: string, onComplete?: () => void) => {
  const parentId = taskId.split('.').slice(0, -1).join('.');
  const isParentExpanded = parentId ? expandedTasks.has(parentId) : true;

  // 设置高亮
  setHighlightedTaskId(taskId);
  setTimeout(() => setHighlightedTaskId(''), 3000);

  if (isParentExpanded) {
    // 父任务已展开，直接滚动到目标
    const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
    if (taskElement) {
      taskElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
      if (onComplete) onComplete();
    }
  } else {
    // 父任务折叠，需要双层滚动
    // 第一步：滚动到父任务位置，显示子任务区域
    const parentElement = document.querySelector(`[data-task-id="${parentId}"]`);
    if (parentElement) {
      parentElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    // 第二步：滚动子任务区域到目标任务
    setTimeout(() => {
      const targetElement = document.querySelector(`[data-task-id="${taskId}"]`);
      if (targetElement) {
        const parentLi = parentElement;
        if (parentLi) {
          const childrenUl = parentLi.querySelector(':scope > .children, :scope > ul');
          if (childrenUl) {
            const childrenRect = childrenUl.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            const relativeTop = targetRect.top - childrenRect.top;

            childrenUl.scrollTo({
              top: childrenUl.scrollTop + relativeTop,
              behavior: 'smooth'
            });
          }
        }
      }
      if (onComplete) onComplete();
    }, 100);
  }
};
```

#### TaskList.css

新增高亮样式：
```css
/* 【R51.9】任务高亮定位样式 */
.task-card-highlighted {
  border-color: #007acc !important;
  box-shadow: 0 0 12px rgba(0, 122, 204, 0.4);
  animation: highlightPulse 1.5s ease-in-out infinite;
}

.task-card-highlighted .task-id {
  color: #007acc;
  font-weight: 600;
}

@keyframes highlightPulse {
  0%, 100% { box-shadow: 0 0 8px rgba(0, 122, 204, 0.3); }
  50% { box-shadow: 0 0 16px rgba(0, 122, 204, 0.5); }
}
```

## 滚动行为说明

### 场景1：父任务已展开

```
[主容器滚动] → 直接滚动到 R3.14 位置
```

### 场景2：父任务折叠（R3折叠）

```
[主容器滚动] → 滚动到 R3 位置（显示子任务区域，300px高度）
    ↓
[子任务区域滚动] → 滚动子任务ul内部到 R3.14 位置
```

折叠状态下，子任务区域有 `max-height: 300px` 和 `overflow-y: auto`，所有子任务都被渲染但只显示在300px区域内。通过第二层滚动可以将目标子任务滚动到可见位置。

## 验证结果

- 编译成功 (webpack 5.104.1)
- 所有修改均为 TypeScript 语法正确

## 问题与修复

### 问题1：滚动到底效果干扰跳转定位

**现象**：跳转到子任务时，目标子任务被滚动到子任务区域底部，而非正确位置。

**原因分析**：
- R48.1 的"收起状态切换时滚动到底"效果会在展开状态变化时触发
- 原来使用 `expandedTasks.size === 0` 判断首次加载，但 webview 重新加载或切换文件时也会导致该条件为 true
- 跳转操作期间，`scrollIntoView` 触发 React 重新渲染，导致 useEffect 被触发

**解决方案**：

1. 新增 `isJumpOperationInProgress` 状态标志 (TaskList.tsx 第109-110行)：
```typescript
// 【R51.9】标记跳转操作进行中，用于防止滚动到底效果干扰跳转
const [isJumpOperationInProgress, setIsJumpOperationInProgress] = React.useState(false);
```

2. 新增 `isInitialMountRef` 跟踪首次挂载 (第111-112行)：
```typescript
// 【R51.9】跟踪组件是否首次挂载，用于首次加载时滚动到底
const isInitialMountRef = React.useRef(true);
```

3. 修改 `scrollToTask` 函数 (第659-698行)：
```typescript
// 设置跳转操作进行中标志，防止滚动到底效果干扰
setIsJumpOperationInProgress(true);
// ... 执行滚动 ...
// 延迟清除跳转操作标志
setTimeout(() => {
  setIsJumpOperationInProgress(false);
  if (onComplete) onComplete();
}, 400);
```

4. 分离滚动到底逻辑为两个独立的 useEffect：
   - **首个 useEffect** (第1537-1556行)：只响应 `isCollapseAllTriggered` 变化
   - **第二个 useEffect** (第1558-1576行)：空依赖数组，只在组件首次挂载时执行一次

```typescript
// 【R51.9】首次挂载时滚动到底（只在挂载时执行一次）
React.useEffect(() => {
  if (isInitialMountRef.current) {
    isInitialMountRef.current = false;
    // ... 滚动到底逻辑
  }
  return () => {};
}, []); // 空依赖数组，只在挂载时执行一次
```

**效果**：
- 跳转操作期间：`isJumpOperationInProgress` 为 true，阻止滚动到底效果
- 首次加载时：空依赖数组的 useEffect 确保只执行一次
- 全部收起操作：`isCollapseAllTriggered` 触发独立的 useEffect

## 效果对比

| 场景 | 之前行为 | 现在行为 |
|------|----------|----------|
| 跳转已展开的子任务 | 滚动定位 + 高亮 | 滚动定位 + 高亮 |
| 跳转折叠的子任务 | 自动展开父任务再定位 | 双层滚动定位 + 高亮（不展开） |
| 跳转时滚动到底干扰 | 目标被滚动到底部 | 正确滚动到目标位置 |

用户可以看到目标子任务被高亮定位，如果需要查看详细内容，可以手动展开父任务。
