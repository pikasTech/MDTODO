# R51.14 任务报告 - 折叠状态下跳转问题调查报告

## 任务描述（修订版）

**约束条件**：必须在折叠状态下滚动，**禁止展开**。

1. 顶级 Rx 跳转到顶部，并且要完整显示 Rx 的内容（现在 Rx 的底部对齐到了顶端，这样 Rx 的内容被完全遮盖了）
2. 内部 Rx.x, Rx.x.x 等都要跳转到居中，这个居中指的是内部滚动条的居中，不动外部滚动条，外部滚动条由 1 的原则来跳转（现在有时候置顶，有时候居中，有时候又不滚动）

## 问题分析

### 当前代码行为分析

#### scrollToTask 函数 (TaskList.tsx:646-708)

```typescript
if (!isAllCollapsed) {
  // 全局未折叠：执行完整双层滚动
  if (targetElement) {
    if (parentElement) {
      // 第一步：滚动主容器到父任务位置（外层跳转，顶部对齐）
      parentElement.scrollIntoView({ behavior: 'smooth', block: 'start' });

      // 第二步：滚动子任务区域到目标位置（内层跳转，居中）
      setTimeout(() => {
        // ... 内层居中滚动逻辑
      }, 300);
    } else {
      // 顶级任务：直接滚动到目标（顶部对齐）
      targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }
} else {
  // 全局折叠：只做外层滚动到父任务顶部，不改变折叠状态
  if (parentElement) {
    parentElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
  } else if (targetElement) {
    targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}
```

### 问题根因

#### 问题 1：顶级 Rx 跳转后内容被遮盖

**原因**：`scrollIntoView({ block: 'start' })` 在嵌套滚动容器中表现不稳定。

**具体情况**：
- 顶级任务使用 `scrollIntoView({ block: 'start' })` 尝试将元素顶部对齐容器顶部
- 在有双重滚动结构的情况下，外层滚动可能将任务推到视口外，导致只有部分可见或完全不可见
- `scrollIntoView` 依赖最近的滚动祖先，可能不是期望的 `.task-container`

#### 问题 2：折叠状态下内部任务跳转行为不一致

**原因**：
1. 折叠状态下当前代码只做外层滚动，不做内层滚动
2. `scrollIntoView` 在元素被隐藏（`display: none`）时无法正确计算位置
3. 折叠状态下子任务区域虽然存在，但可能因为父元素折叠导致布局计算异常

**折叠状态下的 DOM 结构**：
```
R2 (可见，isExpanded = false)
  └── .children (display: none 或 visibility: hidden)
        └── R2.1 (DOM中存在，但不可见)
        └── R2.2 (DOM中存在，但不可见)
        └── R2.2.1 (DOM中存在，但不可见)
```

即使子任务被隐藏，只要 DOM 元素存在，仍然可以计算其位置并执行滚动。

### 折叠/展开机制分析

当前使用全局折叠状态 `isAllCollapsed`：
- `isAllCollapsed = false`：所有任务展开
- `isAllCollapsed = true`：所有任务折叠

每个 TaskItem 组件根据 `isAllCollapsed` 决定是否显示子任务：

```typescript
// TaskItem.tsx
const isExpanded = !isAllCollapsed;
// 当 isExpanded = false 时，子任务容器被隐藏
```

## 解决方案（修订版）

### 核心原则

1. **禁止展开**：任何情况下都不改变 `isAllCollapsed` 状态
2. **精确滚动计算**：使用 `getBoundingClientRect()` 和 `scrollTo()` 替代不稳定的 `scrollIntoView`
3. **分离外层和内层滚动**：外层滚动到顶级任务顶部，内层滚动到内部任务居中

### 方案设计

#### 目标 1：修复顶级 Rx 跳转后内容被遮盖的问题

**方案**：对于顶级任务，使用 `.task-container` 的精确滚动计算

```typescript
const container = document.querySelector('.task-container');
if (container && targetElement) {
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  // 计算目标元素顶部相对于容器顶部的位置
  const relativeTop = targetRect.top - containerRect.top;
  // 计算正确的 scrollTop 值
  const scrollTop = container.scrollTop + relativeTop;
  container.scrollTo({ top: scrollTop, behavior: 'smooth' });
}
```

这样可以确保顶级任务从容器顶部开始完整显示。

#### 目标 2：折叠状态下内部任务跳转到内层居中

**方案**：
1. 外层滚动：滚动到父任务（顶级）到顶部
2. 内层滚动：计算目标在父任务子任务容器中的位置，让目标居中

**关键点**：
- 折叠状态下子任务容器虽然隐藏，但 DOM 元素存在
- 使用 `getBoundingClientRect()` 可以获取元素相对于视口的位置
- 通过相对位置计算可以在隐藏状态下正确滚动

```typescript
if (parentElement) {
  // 第一步：外层滚动到父任务（顶级）到顶部
  const container = document.querySelector('.task-container');
  const parentRect = parentElement.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  const parentRelativeTop = parentRect.top - containerRect.top;
  container.scrollTo({
    top: container.scrollTop + parentRelativeTop,
    behavior: 'smooth'
  });

  // 第二步：内层滚动到目标居中（不动外层滚动条）
  setTimeout(() => {
    const childrenUl = parentElement.querySelector(':scope > .children, :scope > ul');
    if (childrenUl && targetElement) {
      const childrenRect = childrenUl.getBoundingClientRect();
      const targetRect = targetElement.getBoundingClientRect();

      // 计算目标在子任务容器中的相对位置
      const targetRelativeTop = targetRect.top - childrenRect.top;
      const targetHeight = targetElement.offsetHeight;
      const containerHeight = childrenUl.clientHeight;

      // 计算居中的 scrollTop
      const scrollTop = childrenUl.scrollTop + targetRelativeTop - (containerHeight - targetHeight) / 2;
      childrenUl.scrollTo({ top: scrollTop, behavior: 'smooth' });
    }
  }, 300);
}
```

## 修改计划

### 修改文件

- `src/webview/components/TaskList.tsx` - 修改 `scrollToTask` 函数

### 修改内容

1. **移除 `scrollIntoView` 调用**：改用精确的 `scrollTo` 计算
2. **统一滚动逻辑**：无论是否折叠，内部任务都执行双重滚动（外层顶部 + 内层居中）
3. **顶级任务特殊处理**：只做外层滚动到顶部，确保内容完整显示

### 预期行为

| 场景 | 行为 |
|------|------|
| 顶级任务 Rx | 外层滚动到 Rx 顶部，完整显示 Rx 内容 |
| 内部任务 Rx.x | 外层滚动到 Rx 顶部 + 内层滚动到 Rx.x 居中 |
| 内部任务 Rx.x.x | 外层滚动到 Rx 顶部 + 内层滚动到 Rx.x.x 居中 |

所有操作都在折叠状态下执行，不改变折叠状态。
