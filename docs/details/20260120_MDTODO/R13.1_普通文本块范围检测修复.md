# R13.1 普通文本块范围检测修复

## 任务描述

渲染普通文本块的范围检测错误，以本文档为例，普通文本块是从 `##总需求` 开始，到 `##R1` 之前结束，并且这部分内容渲染为一个普通文本块而不是多个。

## 问题分析

原有实现 (`src/parser/index.ts`) 将每一行非 RXX 格式的内容都作为单独的 `TextBlock`，导致：
- `##总需求` 及其描述内容被分割成多个独立块
- 无法正确识别连续的非 RXX 内容范围

## 修复方案

修改 `parseTextBlocks` 方法，实现连续非 RXX 内容的合并逻辑：

1. 遍历所有行，识别 RXX 任务标题的边界
2. 将连续的普通文本内容（从非 RXX 标题开始，到下一个 RXX 标题之前）合并为一个 `TextBlock`
3. 保留行内的 Markdown 格式（包括链接等）

### 核心逻辑

```typescript
parseTextBlocks(content: string): TextBlock[] {
  const lines = content.split('\n');
  const textBlocks: TextBlock[] = [];

  let currentBlockLines: string[] = [];
  let blockStartLine = -1;
  let inTextBlock = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();

    // 检查是否是 ## 或 ### 或 #### 开头
    const isHeading = trimmed.match(/^#{2,}\s/);
    // 检查是否包含 RXX 格式
    const hasRxx = hasRxxId(trimmed);

    // 如果是 RXX 任务标题，结束当前文本块
    if (isHeading && hasRxx) {
      if (inTextBlock && currentBlockLines.length > 0) {
        textBlocks.push({
          id: `text-${blockStartLine}`,
          content: currentBlockLines.join('\n').trim(),
          lineNumber: blockStartLine
        });
      }
      currentBlockLines = [];
      inTextBlock = false;
      blockStartLine = -1;
    }
    // 如果是普通文本行（标题或段落），加入当前块
    else if (trimmed) {
      if (!inTextBlock) {
        inTextBlock = true;
        blockStartLine = i;
      }
      currentBlockLines.push(line);
    }
    // 空行：不影响当前块，继续收集
    else {
      if (inTextBlock) {
        currentBlockLines.push(line);
      }
    }
  }

  // 处理最后一个文本块
  if (inTextBlock && currentBlockLines.length > 0) {
    textBlocks.push({
      id: `text-${blockStartLine}`,
      content: currentBlockLines.join('\n').trim(),
      lineNumber: blockStartLine
    });
  }

  return textBlocks;
}
```

## 验证结果

使用测试数据验证，修复后：
- 从 `##总需求` 开始到 `##R1` 之前的内容被合并为 **1 个文本块**
- 文本块内容完整包含所有原始文本和格式

## 修改文件

- `src/parser/index.ts` - `parseTextBlocks` 方法

## 执行日期

2026-01-21
