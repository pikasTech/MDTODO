# R12.1 编辑功能改进执行记录

## 任务概述

修复 R12 中的两个遗留问题：
1. 回车后要退出编辑模式，和点击"完成"的效果一样才行
2. 编辑的对象是任务内容，任务内容是在 RXX 换行之后的，而不是和 RXX 同行的

## 执行时间

2026-01-21

## 修改文件

1. `vscode-mdtodo/src/webview/components/TaskList.tsx`
2. `vscode-mdtodo/src/webview/index.tsx`
3. `vscode-mdtodo/src/providers/webviewProvider.ts`

## 修改内容

### 1. 回车后退出编辑模式

**问题分析**：
- 原代码中 `handleTitleBlur` 在保存后没有清除 `editModes` 状态
- 导致回车保存后编辑模式没有退出，需要点击"完成"按钮才能退出

**解决方案**：
- 在 `TaskList.tsx` 中添加 `handleSaveComplete` 函数用于退出编辑模式
- 在 `handleTitleBlur` 中调用 `handleSaveComplete` 确保回车和点击完成效果一致
- 通过全局变量 `window.MDTODO.setSaveCompleteCallback` 实现组件间的回调传递

**关键代码变更** (`TaskList.tsx`):
```typescript
// 保存完成后退出编辑模式的处理函数
const handleSaveComplete = (taskId: string) => {
  setEditModes((prev) => ({
    ...prev,
    [taskId]: false,
  }));
};

const handleTitleBlur = (e: React.FocusEvent<HTMLDivElement>, taskId: string) => {
  const target = e.currentTarget as HTMLDivElement;
  const newTitle = target.textContent?.trim() || '';
  if (newTitle) {
    onSaveTitle(taskId, newTitle);
    // 保存完成后退出编辑模式
    handleSaveComplete(taskId);
  }
};
```

**关键代码变更** (`index.tsx`):
```typescript
// 用于存储保存完成后的回调，用于退出编辑模式
let saveCompleteCallback: ((taskId: string) => void) | null = null;

// 保存完成回调设置函数（通过全局变量暴露给 TaskList）
window.MDTODO.setSaveCompleteCallback = (callback: (taskId: string) => void) => {
  saveCompleteCallback = callback;
};
```

### 2. 编辑任务内容而非 RXX 同行

**问题分析**：
- 原代码 `handleSaveTitle` 只更新了 RXX 那行的标题
- 但用户编辑的实际上是任务内容（在 RXX 换行后的描述）

**解决方案**：
- 修改 `handleSaveTitle` 方法，查找 RXX 任务行后的第一个非空行作为内容行
- 如果没有内容行，则在任务标题后插入新内容
- 如果遇到下一个任务标题（同级或更高级），说明当前任务没有内容，插入新内容

**关键代码变更** (`webviewProvider.ts`):
```typescript
private async handleSaveTitle(taskId: string, newTitle: string): Promise<void> {
  // ... 省略文件读取逻辑

  // 找到任务所在的行
  let taskLineIndex = -1;
  let taskLevel = 0;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const taskPattern = new RegExp(`^##+\\s+[^\\n]*\\b${taskId.replace(/\./g, '\\.')}(?:[)\\s]|$)`);
    if (taskPattern.test(line)) {
      taskLineIndex = i;
      const match = line.match(/^(#+)/);
      taskLevel = match ? match[1].length : 2;
      break;
    }
  }

  // 查找任务内容行（RXX 换行后的第一个非空行）
  let contentLineIndex = -1;
  for (let i = taskLineIndex + 1; i < lines.length; i++) {
    const line = lines[i].trim();
    // 如果遇到空行继续查找
    if (line === '') {
      continue;
    }
    // 如果遇到下一个任务标题（同级或更高级），说明没有内容行
    if (line.match(/^##+\s+/) && line.match(/R\d+(?:\.\d+)*/)) {
      const nextMatch = line.match(/^(#+)/);
      const nextLevel = nextMatch ? nextMatch[1].length : 2;
      if (nextLevel <= taskLevel) {
        // 没有内容行，在任务标题后添加内容
        contentLineIndex = taskLineIndex + 1;
        lines.splice(contentLineIndex, 0, newTitle);
        break;
      }
    }
    // 找到内容行，更新内容
    contentLineIndex = i;
    lines[contentLineIndex] = newTitle;
    break;
  }

  // 如果任务标题后没有内容，添加新内容行
  if (contentLineIndex === -1) {
    contentLineIndex = taskLineIndex + 1;
    lines.splice(contentLineIndex, 0, newTitle);
  }

  // ... 省略文件写入逻辑
}
```

## 测试建议

1. **回车退出编辑模式测试**：
   - 双击任务进入编辑模式
   - 修改内容后按回车
   - 验证是否正确保存并退出编辑模式

2. **点击完成退出编辑模式测试**：
   - 双击任务进入编辑模式
   - 修改内容后点击"完成"按钮
   - 验证是否正确保存并退出编辑模式

3. **编辑任务内容测试**：
   - 编辑 R12.1 的任务内容（换行后的描述）
   - 保存后验证 md 文件中是否正确更新了内容行
   - 验证 RXX 同行的标题没有被修改

4. **边界情况测试**：
   - 任务后没有内容行的情况
   - 任务内容为多行的情况
   - 嵌套子任务的内容编辑

## 注意事项

1. 构建命令：`npm run compile`
2. 构建后的文件在 `resources/` 目录下
3. 测试时需要在 VSCode 中重新加载插件
