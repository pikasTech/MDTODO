# R29.1 双向滚动同步实现 - 焦点跟踪机制

## 任务描述

R29.1 是 R29 的子任务：

> 现在md源文件到MDTODO webview 的同步实现了，但是MDTODO 到 md 源文件的同步没有实现，应该是聚焦到哪个上面，哪个就是主动的，另一个是被动跟随的。

## 问题分析

原实现存在以下问题：

1. **单向同步**：只有 md → webview 的同步，缺少 webview → md 的同步
2. **无焦点跟踪**：没有实现"聚焦哪个，哪个就主动"的逻辑
3. **冲突问题**：两个视图可能同时触发滚动同步，导致冲突

## 实现方案

### 1. 焦点状态跟踪

在 `webviewProvider.ts` 中添加焦点状态变量：

```typescript
private scrollSyncActiveView: 'editor' | 'webview' = 'editor';
```

### 2. 双向同步逻辑

- **当 editor 是主动视图时**：
  - editor 滚动 → 同步到 webview
  - webview 滚动 → 不同步到 editor

- **当 webview 是主动视图时**：
  - webview 滚动 → 同步到 editor
  - editor 滚动 → 不同步到 webview

### 3. 焦点切换机制

#### VSCode 编辑器焦点
```typescript
vscode.window.onDidChangeActiveTextEditor((editor) => {
  if (editor && this.currentFilePath &&
      editor.document.uri.fsPath === this.currentFilePath) {
    this.scrollSyncActiveView = 'editor';
  }
});
```

#### Webview 焦点
```typescript
this.panel.onDidChangeViewState((event) => {
  if (event.webviewPanel.active) {
    this.scrollSyncActiveView = 'webview';
  }
});
```

#### 用户交互触发（点击/滚动 webview）
Webview 发送 `webviewActive` 消息，extension 接收后设置 webview 为主动视图。

## 代码修改

### 1. webviewProvider.ts 修改

#### 添加焦点状态变量
```typescript
private scrollSyncActiveView: 'editor' | 'webview' = 'editor';
```

#### 修改 setupScrollSync 方法
```typescript
public setupScrollSync(): void {
  // 编辑器滚动事件 - 只在 editor 是主动视图时同步
  vscode.window.onDidChangeTextEditorVisibleRanges((event) => {
    if (this.scrollSyncActiveView !== 'editor') {
      return;  // webview 是主动视图，不同步
    }
    // ... 同步逻辑
  });

  // 监听编辑器焦点变化
  vscode.window.onDidChangeActiveTextEditor((editor) => {
    if (editor && this.currentFilePath &&
        editor.document.uri.fsPath === this.currentFilePath) {
      this.scrollSyncActiveView = 'editor';
    }
  });

  // 监听 webview 面板焦点变化
  if (this.panel) {
    this.panel.onDidChangeViewState((event) => {
      if (event.webviewPanel.active) {
        this.scrollSyncActiveView = 'webview';
      }
    });
  }
}
```

#### 修改 handleWebviewScrolled 方法
```typescript
private async handleWebviewScrolled(taskId: string, lineNumber: number): Promise<void> {
  // 只当 webview 是主动视图时才同步
  if (this.scrollSyncActiveView !== 'webview') {
    return;
  }
  // ... 同步逻辑
}
```

#### 添加消息处理
```typescript
case 'webviewActive':
  this.setWebviewAsActive();
  break;
```

### 2. TaskList.tsx 修改

#### 添加焦点通知函数
```typescript
const notifyWebviewActive = React.useCallback(() => {
  sendMessage({ type: 'webviewActive' });
}, [sendMessage]);
```

#### 修改滚动事件监听
```typescript
React.useEffect(() => {
  const container = document.querySelector('.task-container');
  if (container) {
    const handleScrollWithFocus = () => {
      notifyWebviewActive();
      handleScroll();
    };

    container.addEventListener('scroll', handleScrollWithFocus, { passive: true });
    container.addEventListener('click', notifyWebviewActive, { passive: true });

    return () => {
      container.removeEventListener('scroll', handleScrollWithFocus);
      container.removeEventListener('click', notifyWebviewActive);
    };
  }
}, [handleScroll, notifyWebviewActive]);
```

#### 修改 handleScroll 函数
```typescript
const handleScroll = React.useCallback(() => {
  // ... 查找可见任务逻辑

  if (topmostTask && topmostTask.id !== lastScrollTaskRef.current) {
    // 发送滚动消息前先通知 webview 成为焦点
    sendMessage({ type: 'webviewActive' });
    sendMessage({
      type: 'webviewScrolled',
      taskId: topmostTask.id,
      lineNumber: topmostTask.lineNumber
    });
  }
}, [tasks, sendMessage]);
```

## 测试验证

### 测试步骤

1. 打开一个 MDTODO 文件（左侧编辑器）
2. 打开 MDTODO 插件（右侧 webview）
3. **测试 editor → webview 同步**：
   - 在编辑器中滚动，观察 webview 是否同步滚动
   - 点击编辑器确保焦点在编辑器上

4. **测试 webview → editor 同步**：
   - 点击 webview 确保焦点在 webview 上
   - 在 webview 中滚动，观察编辑器是否同步滚动

5. **测试焦点切换**：
   - 先在 editor 中滚动，焦点在 editor
   - 点击 webview，焦点切换到 webview
   - 在 webview 中滚动，观察是否同步到 editor
   - 切换回 editor，再滚动，观察是否同步到 webview

### 预期行为

- 聚焦哪个视图，哪个视图滚动时就会同步到另一个视图
- 另一个视图滚动时不会触发同步
- 通过点击或滚动可以切换主动视图

## 总结

本实现通过焦点状态跟踪机制，实现了"聚焦哪个，哪个就主动"的双向滚动同步功能，解决了之前 webview → editor 同步失效的问题。
